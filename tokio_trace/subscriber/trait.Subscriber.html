<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Subscriber` trait in crate `tokio_trace`."><meta name="keywords" content="rust, rustlang, rust-lang, Subscriber"><title>tokio_trace::subscriber::Subscriber - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Trait Subscriber</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.enabled">enabled</a><a href="#tymethod.new_span">new_span</a><a href="#tymethod.record">record</a><a href="#tymethod.record_follows_from">record_follows_from</a><a href="#tymethod.event">event</a><a href="#tymethod.enter">enter</a><a href="#tymethod.exit">exit</a></div><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.register_callsite">register_callsite</a><a href="#method.clone_span">clone_span</a><a href="#method.drop_span">drop_span</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../index.html'>tokio_trace</a>::<wbr><a href='index.html'>subscriber</a></p><script>window.sidebarCurrent = {name: 'Subscriber', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/tokio_trace_core/subscriber.rs.html#36-243' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='../index.html'>tokio_trace</a>::<wbr><a href='index.html'>subscriber</a>::<wbr><a class="trait" href=''>Subscriber</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait Subscriber {
    fn <a href='#tymethod.enabled' class='fnname'>enabled</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;
<div class='item-spacer'></div>    fn <a href='#tymethod.new_span' class='fnname'>new_span</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>, values: &amp;<a class="struct" href="../../tokio_trace/field/struct.ValueSet.html" title="struct tokio_trace::field::ValueSet">ValueSet</a>) -&gt; <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>;
<div class='item-spacer'></div>    fn <a href='#tymethod.record' class='fnname'>record</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>, values: &amp;<a class="struct" href="../../tokio_trace/field/struct.ValueSet.html" title="struct tokio_trace::field::ValueSet">ValueSet</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.record_follows_from' class='fnname'>record_follows_from</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>, follows: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.event' class='fnname'>event</a>(&amp;self, event: &amp;<a class="struct" href="../../tokio_trace/event/struct.Event.html" title="struct tokio_trace::event::Event">Event</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.enter' class='fnname'>enter</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.exit' class='fnname'>exit</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>);

    fn <a href='#method.register_callsite' class='fnname'>register_callsite</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>) -&gt; <a class="struct" href="../../tokio_trace/subscriber/struct.Interest.html" title="struct tokio_trace::subscriber::Interest">Interest</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.clone_span' class='fnname'>clone_span</a>(&amp;self, id: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>) -&gt; <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a> { ... }
<div class='item-spacer'></div>    fn <a href='#method.drop_span' class='fnname'>drop_span</a>(&amp;self, id: <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>) { ... }
}</pre></div><div class='docblock'><p>Trait representing the functions required to collect trace data.</p>
<p>Crates that provide implementations of methods for collecting or recording
trace data should implement the <code>Subscriber</code> interface. This trait is
intended to represent fundamental primitives for collecting trace events and
spans — other libraries may offer utility functions and types to make
subscriber implementations more modular or improve the ergonomics of writing
subscribers.</p>
<p>A subscriber is responsible for the following:</p>
<ul>
<li>Registering new spans as they are created, and providing them with span
IDs. Implicitly, this means the subscriber may determine the strategy for
determining span equality.</li>
<li>Recording the attachment of field values and follows-from annotations to
spans.</li>
<li>Filtering spans and events, and determining when those filters must be
invalidated.</li>
<li>Observing spans as they are entered, exited, and closed, and events as
they occur.</li>
</ul>
<p>When a span is entered or exited, the subscriber is provided only with the
<a href="::span::Span">ID</a> with which it tagged that span when it was created. This means
that it is up to the subscriber to determine whether and how span <em>data</em> —
the fields and metadata describing the span — should be stored. The
<a href="::Span::new_span"><code>new_span</code></a> function is called when a new span is created, and at that
point, the subscriber <em>may</em> choose to store the associated data if it will
be referenced again. However, if the data has already been recorded and will
not be needed by the implementations of <code>enter</code> and <code>exit</code>, the subscriber
may freely discard that data without allocating space to store it.</p>
</div>
            <h2 id='required-methods' class='small-section-header'>
              Required Methods<a href='#required-methods' class='anchor'></a>
            </h2>
            <div class='methods'>
        <h3 id='tymethod.enabled' class='method'><span id='enabled.v' class='invisible'><code>fn <a href='#tymethod.enabled' class='fnname'>enabled</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h3><div class='docblock'><p>Returns true if a span with the specified <a href="::Metadata">metadata</a> would be
recorded.</p>
<p>This is used by the dispatcher to avoid allocating for span construction
if the span would be discarded anyway.</p>
</div><h3 id='tymethod.new_span' class='method'><span id='new_span.v' class='invisible'><code>fn <a href='#tymethod.new_span' class='fnname'>new_span</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>, values: &amp;<a class="struct" href="../../tokio_trace/field/struct.ValueSet.html" title="struct tokio_trace::field::ValueSet">ValueSet</a>) -&gt; <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a></code></span></h3><div class='docblock'><p>Record the construction of a new <a href="::span::Span"><code>Span</code></a>, returning a new ID for the
span being constructed.</p>
<p>The provided <code>ValueSet</code> contains any field values that were provided
when the span was created. The subscriber may pass a <a href="::field::Record">recorder</a> to the
<code>ValueSet</code>'s <a href="::field::ValueSet::record"><code>record</code> method</a> to record these values.</p>
<p>IDs are used to uniquely identify spans and events within the context of a
subscriber, so span equality will be based on the returned ID. Thus, if
the subscriber wishes for all spans with the same metadata to be
considered equal, it should return the same ID every time it is given a
particular set of metadata. Similarly, if it wishes for two separate
instances of a span with the same metadata to <em>not</em> be equal, it should
return a distinct ID every time this function is called, regardless of
the metadata.</p>
</div><h3 id='tymethod.record' class='method'><span id='record.v' class='invisible'><code>fn <a href='#tymethod.record' class='fnname'>record</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>, values: &amp;<a class="struct" href="../../tokio_trace/field/struct.ValueSet.html" title="struct tokio_trace::field::ValueSet">ValueSet</a>)</code></span></h3><div class='docblock'><p>Record a set of values on a span.</p>
<p>The subscriber is expected to provide a <a href="::field::Record">recorder</a> to the <code>ValueSet</code>'s
<a href="::field::ValueSet::record"><code>record</code> method</a> in order to record the added values.</p>
</div><h3 id='tymethod.record_follows_from' class='method'><span id='record_follows_from.v' class='invisible'><code>fn <a href='#tymethod.record_follows_from' class='fnname'>record_follows_from</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>, follows: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>)</code></span></h3><div class='docblock'><p>Adds an indication that <code>span</code> follows from the span with the id
<code>follows</code>.</p>
<p>This relationship differs somewhat from the parent-child relationship: a
span may have any number of prior spans, rather than a single one; and
spans are not considered to be executing <em>inside</em> of the spans they
follow from. This means that a span may close even if subsequent spans
that follow from it are still open, and time spent inside of a
subsequent span should not be included in the time its precedents were
executing. This is used to model causal relationships such as when a
single future spawns several related background tasks, et cetera.</p>
<p>If the subscriber has spans corresponding to the given IDs, it should
record this relationship in whatever way it deems necessary. Otherwise,
if one or both of the given span IDs do not correspond to spans that the
subscriber knows about, or if a cyclical relationship would be created
(i.e., some span <em>a</em> which proceeds some other span <em>b</em> may not also
follow from <em>b</em>), it may silently do nothing.</p>
</div><h3 id='tymethod.event' class='method'><span id='event.v' class='invisible'><code>fn <a href='#tymethod.event' class='fnname'>event</a>(&amp;self, event: &amp;<a class="struct" href="../../tokio_trace/event/struct.Event.html" title="struct tokio_trace::event::Event">Event</a>)</code></span></h3><div class='docblock'><p>Records that an <a href="::event::Event"><code>Event</code></a> has occurred.</p>
<p>The provided <code>Event</code> struct contains any field values attached to the
event. The subscriber may pass a <a href="::field::Record">recorder</a> to the <code>Event</code>'s
<a href="::event::Event::record"><code>record</code> method</a> to record these values.</p>
</div><h3 id='tymethod.enter' class='method'><span id='enter.v' class='invisible'><code>fn <a href='#tymethod.enter' class='fnname'>enter</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>)</code></span></h3><div class='docblock'><p>Records that a <a href="::span::Span"><code>Span</code></a> has been entered.</p>
<p>When entering a span, this method is called to notify the subscriber
that the span has been entered. The subscriber is provided with the ID
of the entered span, and should update any internal state tracking the
current span accordingly.</p>
</div><h3 id='tymethod.exit' class='method'><span id='exit.v' class='invisible'><code>fn <a href='#tymethod.exit' class='fnname'>exit</a>(&amp;self, span: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>)</code></span></h3><div class='docblock'><p>Records that a <a href="::span::Span"><code>Span</code></a> has been exited.</p>
<p>When entering a span, this method is called to notify the subscriber
that the span has been exited. The subscriber is provided with the ID
of the exited span, and should update any internal state tracking the
current span accordingly.</p>
<p>Exiting a span does not imply that the span will not be re-entered.</p>
</div></div>
            <h2 id='provided-methods' class='small-section-header'>
              Provided Methods<a href='#provided-methods' class='anchor'></a>
            </h2>
            <div class='methods'>
        <h3 id='method.register_callsite' class='method'><span id='register_callsite.v' class='invisible'><code>fn <a href='#method.register_callsite' class='fnname'>register_callsite</a>(&amp;self, metadata: &amp;<a class="struct" href="../../tokio_trace/struct.Metadata.html" title="struct tokio_trace::Metadata">Metadata</a>) -&gt; <a class="struct" href="../../tokio_trace/subscriber/struct.Interest.html" title="struct tokio_trace::subscriber::Interest">Interest</a></code></span></h3><div class='docblock'><p>Registers a new callsite with this subscriber, returning whether or not
the subscriber is interested in being notified about the callsite.</p>
<p>By default, this function assumes that the subscriber's filter
represents an unchanging view of its interest in the callsite. However,
if this is not the case, subscribers may override this function to
indicate different interests, or to implement behaviour that should run
once for every callsite.</p>
<p>This function is guaranteed to be called exactly once per callsite on
every active subscriber. The subscriber may store the keys to fields it
cares in order to reduce the cost of accessing fields by name,
preallocate storage for that callsite, or perform any other actions it
wishes to perform once for each callsite.</p>
<p>The subscriber should then return an <a href="Interest"><code>Interest</code></a>, indicating
whether it is interested in being notified about that callsite in the
future. This may be <code>Always</code> indicating that the subscriber always
wishes to be notified about the callsite, and its filter need not be
re-evaluated; <code>Sometimes</code>, indicating that the subscriber may sometimes
care about the callsite but not always (such as when sampling), or
<code>Never</code>, indicating that the subscriber never wishes to be notified about
that callsite. If all active subscribers return <code>Never</code>, a callsite will
never be enabled unless a new subscriber expresses interest in it.</p>
<p><code>Subscriber</code>s which require their filters to be run every time an event
occurs or a span is entered/exited should return <code>Interest::Sometimes</code>.</p>
<p>For example, suppose a sampling subscriber is implemented by
incrementing a counter every time <code>enabled</code> is called and only returning
<code>true</code> when the counter is divisible by a specified sampling rate. If
that subscriber returns <code>Interest::Always</code> from <code>register_callsite</code>, then
the filter will not be re-evaluated once it has been applied to a given
set of metadata. Thus, the counter will not be incremented, and the span
or event that correspands to the metadata will never be <code>enabled</code>.</p>
<p>Similarly, if a <code>Subscriber</code> has a filtering strategy that can be
changed dynamically at runtime, it would need to re-evaluate that filter
if the cached results have changed.</p>
<p>A subscriber which manages fanout to multiple other subscribers
should proxy this decision to all of its child subscribers,
returning <code>Interest::Never</code> only if <em>all</em> such children return
<code>Interest::Never</code>. If the set of subscribers to which spans are
broadcast may change dynamically, the subscriber should also never
return <code>Interest::Never</code>, as a new subscriber may be added that <em>is</em>
interested.</p>
<p><strong>Note</strong>: If a subscriber returns <code>Interest::Never</code> for a particular
callsite, it <em>may</em> still see spans and events originating from that
callsite, if another subscriber expressed interest in it.</p>
</div><h3 id='method.clone_span' class='method'><span id='clone_span.v' class='invisible'><code>fn <a href='#method.clone_span' class='fnname'>clone_span</a>(&amp;self, id: &amp;<a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>) -&gt; <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a></code></span></h3><div class='docblock'><p>Notifies the subscriber that a <a href="::span::Span,"><code>Span</code></a> has been cloned.</p>
<p>This function is guaranteed to only be called with span IDs that were
returned by this subscriber's <code>new_span</code> function.</p>
<p>Note that the default implementation of this function this is just the
identity function, passing through the identifier. However, it can be
used in conjunction with <a href="::subscriber::Subscriber::drop_span"><code>drop_span</code></a> to track the number of handles
capable of <code>enter</code>ing a span. When all the handles have been dropped
(i.e., <code>drop_span</code> has been called one more time than <code>clone_span</code> for a
given ID), the subscriber may assume that the span will not be entered
again. It is then free to deallocate storage for data associated with
that span, write data from that span to IO, and so on.</p>
<p>For more unsafe situations, however, if <code>id</code> is itself a pointer of some
kind this can be used as a hook to &quot;clone&quot; the pointer, depending on
what that means for the specified pointer.</p>
</div><h3 id='method.drop_span' class='method'><span id='drop_span.v' class='invisible'><code>fn <a href='#method.drop_span' class='fnname'>drop_span</a>(&amp;self, id: <a class="struct" href="../../tokio_trace/span/struct.Id.html" title="struct tokio_trace::span::Id">Span</a>)</code></span></h3><div class='docblock'><p>Notifies the subscriber that a <a href="::span::Span,"><code>Span</code></a> has been dropped.</p>
<p>This function is guaranteed to only be called with span IDs that were
returned by this subscriber's <code>new_span</code> function.</p>
<p>It's guaranteed that if this function has been called once more than the
number of times <code>clone_span</code> was called with the same <code>id</code>, then no more
<code>Span</code>s using that <code>id</code> exist. This means that it can be used in
conjunction with [<code>clone_span</code>] to track the number of handles
capable of <code>enter</code>ing a span. When all the handles have been dropped
(i.e., <code>drop_span</code> has been called one more time than <code>clone_span</code> for a
given ID), the subscriber may assume that the span will not be entered
again. It is then free to deallocate storage for data associated with
that span, write data from that span to IO, and so on.</p>
<p><strong>Note</strong>: since this function is called when spans are dropped,
implementations should ensure that they are unwind-safe. Panicking from
inside of a <code>drop_span</code> function may cause a double panic, if the span
was dropped due to a thread unwinding.</p>
</div></div><h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><script type="text/javascript">window.inlined_types=new Set([]);</script><script type="text/javascript" async
                         src="../../implementors/tokio_trace_core/subscriber/trait.Subscriber.js">
                 </script></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "tokio_trace";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>