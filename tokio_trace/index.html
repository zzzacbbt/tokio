<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `tokio_trace` crate."><meta name="keywords" content="rust, rustlang, rust-lang, tokio_trace"><title>tokio_trace - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate tokio_trace</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all tokio_trace's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'tokio_trace', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/tokio_trace/lib.rs.html#1-983' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>tokio_trace</a></span></h1><div class='docblock'><p>A scoped, structured logging and diagnostics system.</p>
<h1 id="overview" class="section-header"><a href="#overview">Overview</a></h1>
<p><code>tokio-trace</code> is a framework for instrumenting Rust programs to collect
structured, event-based diagnostic information.</p>
<p>In asynchronous systems like Tokio, interpreting traditional log messages can
often be quite challenging. Since individual tasks are multiplexed on the same
thread, associated events and log lines are intermixed making it difficult to
trace the logic flow. <code>tokio-trace</code> expands upon logging-style diagnostics by
allowing libraries and applications to record structured events with additional
information about <em>temporality</em> and <em>causality</em> — unlike a log message, a span
in <code>tokio-trace</code> has a beginning and end time, may be entered and exited by the
flow of execution, and may exist within a nested tree of similar spans. In
addition, <code>tokio-trace</code> spans are <em>structured</em>, with the ability to record typed
data as well as textual messages.</p>
<p>The <code>tokio-trace</code> crate provides the APIs necessary for instrumenting libraries
and applications to emit trace data.</p>
<h1 id="core-concepts" class="section-header"><a href="#core-concepts">Core Concepts</a></h1>
<p>The core of <code>tokio-trace</code>'s API is composed of <code>Event</code>s, <code>Span</code>s, and
<code>Subscriber</code>s. We'll cover these in turn.</p>
<h2 id="spans" class="section-header"><a href="#spans"><code>Span</code>s</a></h2>
<p>A <a href="span/struct.Span"><code>Span</code></a> represents a <em>period of time</em> during which a program was executing
in some context. A thread of execution is said to <em>enter</em> a span when it
begins executing in that context, and to <em>exit</em> the span when switching to
another context. The span in which a thread is currently executing is
referred to as the <em>current</em> span.</p>
<p>Spans form a tree structure — unless it is a root span, all spans have a
<em>parent</em>, and may have one or more <em>children</em>. When a new span is created,
the current span becomes the new span's parent. The total execution time of
a span consists of the time spent in that span and in the entire subtree
represented by its children. Thus, a parent span always lasts for at least
as long as the longest-executing span in its subtree.</p>
<p>In addition, data may be associated with spans. A span may have <em>fields</em> —
a set of key-value pairs describing the state of the program during that
span; an optional name, and metadata describing the source code location
where the span was originally entered.</p>
<h3 id="when-to-use-spans" class="section-header"><a href="#when-to-use-spans">When to use spans</a></h3>
<p>As a rule of thumb, spans should be used to represent discrete units of work
(e.g., a given request's lifetime in a server) or periods of time spent in a
given context (e.g., time spent interacting with an instance of an external
system, such as a database).</p>
<p>Which scopes in a program correspond to new spans depend somewhat on user
intent. For example, consider the case of a loop in a program. Should we
construct one span and perform the entire loop inside of that span, like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">span</span><span class="macro">!</span>(<span class="string">&quot;my loop&quot;</span>).<span class="ident">enter</span>(<span class="op">||</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">n</span> {
        <span class="comment">// ...</span>
    }
})</pre></div>
<p>Or, should we create a new span for each iteration of the loop, as in:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">n</span> {
    <span class="macro">span</span><span class="macro">!</span>(<span class="string">&quot;my loop&quot;</span>, <span class="ident">iteration</span> <span class="op">=</span> <span class="ident">i</span>).<span class="ident">enter</span>(<span class="op">||</span> {
        <span class="comment">// ...</span>
    })
}</pre></div>
<p>Depending on the circumstances, we might want to do either, or both. For
example, if we want to know how long was spent in the loop overall, we would
create a single span around the entire loop; whereas if we wanted to know how
much time was spent in each individual iteration, we would enter a new span
on every iteration.</p>
<h2 id="events" class="section-header"><a href="#events">Events</a></h2>
<p>An <a href="struct.Event.html"><code>Event</code></a> represents a <em>point</em> in time. It signifies something that
happened while the trace was executing. <code>Event</code>s are comparable to the log
records emitted by unstructured logging code, but unlike a typical log line,
an <code>Event</code> may occur within the context of a <code>Span</code>. Like a <code>Span</code>, it
may have fields, and implicitly inherits any of the fields present on its
parent span, and it may be linked with one or more additional
spans that are not its parent; in this case, the event is said to <em>follow
from</em> those spans.</p>
<p>Essentially, <code>Event</code>s exist to bridge the gap between traditional
unstructured logging and span-based tracing. Similar to log records, they
may be recorded at a number of levels, and can have unstructured,
human-readable messages; however, they also carry key-value data and exist
within the context of the tree of spans that comprise a trace. Thus,
individual log record-like events can be pinpointed not only in time, but
in the logical execution flow of the system.</p>
<p>Events are represented as a special case of spans — they are created, they
may have fields added, and then they close immediately, without being
entered.</p>
<p>In general, events should be used to represent points in time <em>within</em> a
span — a request returned with a given status code, <em>n</em> new items were
taken from a queue, and so on.</p>
<h2 id="subscribers" class="section-header"><a href="#subscribers"><code>Subscriber</code>s</a></h2>
<p>As <code>Span</code>s and <code>Event</code>s occur, they are recorded or aggregated by
implementations of the <a href="subscriber/trait.Subscriber.html"><code>Subscriber</code></a> trait. <code>Subscriber</code>s are notified
when an <code>Event</code> takes place and when a <code>Span</code> is entered or exited. These
notifications are represented by the following <code>Subscriber</code> trait methods:</p>
<ul>
<li><a href="subscriber/trait.Subscriber.html#tymethod.observe_event"><code>observe_event</code></a>, called when an <code>Event</code> takes place,</li>
<li><a href="subscriber/trait.Subscriber.html#tymethod.enter"><code>enter</code></a>, called when execution enters a <code>Span</code>,</li>
<li><a href="subscriber/trait.Subscriber.html#tymethod.exit"><code>exit</code></a>, called when execution exits a <code>Span</code></li>
</ul>
<p>In addition, subscribers may implement the <a href="subscriber/trait.Subscriber.html#tymethod.enabled"><code>enabled</code></a> function to <em>filter</em>
the notifications they receive based on <a href="struct.Metadata.html">metadata</a> describing each <code>Span</code>
or <code>Event</code>. If a call to <code>Subscriber::enabled</code> returns <code>false</code> for a given
set of metadata, that <code>Subscriber</code> will <em>not</em> be notified about the
corresponding <code>Span</code> or <code>Event</code>. For performance reasons, if no currently
active subscribers express  interest in a given set of metadata by returning
<code>true</code>, then the corresponding <code>Span</code> or <code>Event</code> will never be constructed.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>First, add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
tokio-trace = { git = &quot;https://github.com/tokio-rs/tokio&quot; }
</code></pre>
<p>Next, add this to your crate:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_trace</span>;</pre></div>
<p><code>Span</code>s are constructed using the <code>span!</code> macro, and then <em>entered</em>
to indicate that some code takes place within the context of that <code>Span</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Construct a new span named &quot;my span&quot;.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">span</span> <span class="op">=</span> <span class="macro">span</span><span class="macro">!</span>(<span class="string">&quot;my span&quot;</span>);
<span class="ident">span</span>.<span class="ident">enter</span>(<span class="op">||</span> {
    <span class="comment">// Any trace events in this closure or code called by it will occur within</span>
    <span class="comment">// the span.</span>
});
<span class="comment">// Dropping the span will close it, indicating that it has ended.</span></pre></div>
<p><code>Event</code>s are created using the <code>event!</code> macro, and are recorded when the
event is dropped:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tokio_trace</span>::<span class="ident">Level</span>;
<span class="macro">event</span><span class="macro">!</span>(<span class="ident">Level</span>::<span class="ident">INFO</span>, <span class="string">&quot;something has happened!&quot;</span>);</pre></div>
<p>Users of the <a href="https://docs.rs/log/0.4.6/log/"><code>log</code></a> crate should note that <code>tokio-trace</code> exposes a set of
macros for creating <code>Event</code>s (<code>trace!</code>, <code>debug!</code>, <code>info!</code>, <code>warn!</code>, and
<code>error!</code>) which may be invoked with the same syntax as the similarly-named
macros from the <code>log</code> crate. Often, the process of converting a project to
use <code>tokio-trace</code> can begin with a simple drop-in replacement.</p>
<p>Let's consider the <code>log</code> crate's yak-shaving example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_trace</span>;
<span class="kw">use</span> <span class="ident">tokio_trace</span>::<span class="ident">field</span>;
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">shave_the_yak</span>(<span class="ident">yak</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Yak</span>) {
    <span class="comment">// Create a new span for this invocation of `shave_the_yak`, annotated</span>
    <span class="comment">// with  the yak being shaved as a *field* on the span.</span>
    <span class="macro">span</span><span class="macro">!</span>(<span class="string">&quot;shave_the_yak&quot;</span>, <span class="ident">yak</span> <span class="op">=</span> <span class="ident">field</span>::<span class="ident">debug</span>(<span class="kw-2">&amp;</span><span class="ident">yak</span>)).<span class="ident">enter</span>(<span class="op">||</span> {
        <span class="comment">// Since the span is annotated with the yak, it is part of the context</span>
        <span class="comment">// for everything happening inside the span. Therefore, we don&#39;t need</span>
        <span class="comment">// to add it to the message for this event, as the `log` crate does.</span>
        <span class="macro">info</span><span class="macro">!</span>(<span class="ident">target</span>: <span class="string">&quot;yak_events&quot;</span>, <span class="string">&quot;Commencing yak shaving&quot;</span>);

        <span class="kw">loop</span> {
            <span class="kw">match</span> <span class="ident">find_a_razor</span>() {
                <span class="prelude-val">Ok</span>(<span class="ident">razor</span>) <span class="op">=&gt;</span> {
                    <span class="comment">// We can add the razor as a field rather than formatting it</span>
                    <span class="comment">// as part of the message, allowing subscribers to consume it</span>
                    <span class="comment">// in a more structured manner:</span>
                    <span class="macro">info</span><span class="macro">!</span>({ <span class="ident">razor</span> <span class="op">=</span> <span class="ident">field</span>::<span class="ident">display</span>(<span class="ident">razor</span>) }, <span class="string">&quot;Razor located&quot;</span>);
                    <span class="ident">yak</span>.<span class="ident">shave</span>(<span class="ident">razor</span>);
                    <span class="kw">break</span>;
                }
                <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=&gt;</span> {
                    <span class="comment">// However, we can also create events with formatted messages,</span>
                    <span class="comment">// just as we would for log records.</span>
                    <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;Unable to locate a razor: {}, retrying&quot;</span>, <span class="ident">err</span>);
                }
            }
        }
    })
}</pre></div>
<p>You can find examples showing how to use this crate in the examples
directory.</p>
<h3 id="in-libraries" class="section-header"><a href="#in-libraries">In libraries</a></h3>
<p>Libraries should link only to the <code>tokio-trace</code> crate, and use the provided
macros to record whatever information will be useful to downstream
consumers.</p>
<h3 id="in-executables" class="section-header"><a href="#in-executables">In executables</a></h3>
<p>In order to record trace events, executables have to use a <code>Subscriber</code>
implementation compatible with <code>tokio-trace</code>. A <code>Subscriber</code> implements a
way of collecting trace data, such as by logging it to standard output.</p>
<p>Unlike the <code>log</code> crate, <code>tokio-trace</code> does <em>not</em> use a global <code>Subscriber</code>
which is initialized once. Instead, it follows the <code>tokio</code> pattern of
executing code in a context. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_trace</span>;
<span class="kw">let</span> <span class="ident">my_subscriber</span> <span class="op">=</span> <span class="ident">FooSubscriber</span>::<span class="ident">new</span>();

<span class="ident">tokio_trace</span>::<span class="ident">subscriber</span>::<span class="ident">with_default</span>(<span class="ident">my_subscriber</span>, <span class="op">||</span> {
    <span class="comment">// Any trace events generated in this closure or by functions it calls</span>
    <span class="comment">// will be collected by `my_subscriber`.</span>
})</pre></div>
<p>This approach allows trace data to be collected by multiple subscribers
within different contexts in the program. Alternatively, a single subscriber
may be constructed by the <code>main</code> function and all subsequent code executed
with that subscriber as the default. Any trace events generated outside the
context of a subscriber will not be collected.</p>
<p>The executable itself may use the <code>tokio-trace</code> crate to instrument itself
as well.</p>
<p>The [<code>tokio-trace-nursery</code>] repository contains less stable crates designed
to be used with the <code>tokio-trace</code> ecosystem. It includes a collection of
<code>Subscriber</code> implementations, as well as utility and adapter crates.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use self::span::<a class="struct" href="../tokio_trace/span/struct.Span.html" title="struct tokio_trace::span::Span">Span</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="dispatcher/index.html" title='tokio_trace::dispatcher mod'>dispatcher</a></td><td class='docblock-short'><p>Dispatches trace events to <code>Subscriber</code>s.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="event/index.html" title='tokio_trace::event mod'>event</a></td><td class='docblock-short'><p>Events represent single points in time during the execution of a program.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="field/index.html" title='tokio_trace::field mod'>field</a></td><td class='docblock-short'><p>Structured data associated with <code>Span</code>s and <code>Event</code>s.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="span/index.html" title='tokio_trace::span mod'>span</a></td><td class='docblock-short'><p>Spans represent periods of time in the execution of a program.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="subscriber/index.html" title='tokio_trace::subscriber mod'>subscriber</a></td><td class='docblock-short'><p>Collects and records trace data.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.debug.html" title='tokio_trace::debug macro'>debug</a></td><td class='docblock-short'><p>Constructs an event at the debug level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.error.html" title='tokio_trace::error macro'>error</a></td><td class='docblock-short'><p>Constructs an event at the error level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.event.html" title='tokio_trace::event macro'>event</a></td><td class='docblock-short'><p>Constructs a new <code>Event</code>.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.info.html" title='tokio_trace::info macro'>info</a></td><td class='docblock-short'><p>Constructs an event at the info level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.span.html" title='tokio_trace::span macro'>span</a></td><td class='docblock-short'><p>Constructs a new span.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.trace.html" title='tokio_trace::trace macro'>trace</a></td><td class='docblock-short'><p>Constructs an event at the trace level.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.warn.html" title='tokio_trace::warn macro'>warn</a></td><td class='docblock-short'><p>Constructs an event at the warn level.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Dispatch.html" title='tokio_trace::Dispatch struct'>Dispatch</a></td><td class='docblock-short'><p><code>Dispatch</code> trace data to a <a href="::Subscriber"><code>Subscriber</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Event.html" title='tokio_trace::Event struct'>Event</a></td><td class='docblock-short'><p><code>Event</code>s represent single points in time where something occurred during the
execution of a program.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Level.html" title='tokio_trace::Level struct'>Level</a></td><td class='docblock-short'><p>Describes the level of verbosity of a <code>Span</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Metadata.html" title='tokio_trace::Metadata struct'>Metadata</a></td><td class='docblock-short'><p>Metadata describing a <a href="::span::Span"><code>Span</code></a>.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Subscriber.html" title='tokio_trace::Subscriber trait'>Subscriber</a></td><td class='docblock-short'><p>Trait representing the functions required to collect trace data.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Value.html" title='tokio_trace::Value trait'>Value</a></td><td class='docblock-short'><p>A field value of an erased type.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "tokio_trace";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>